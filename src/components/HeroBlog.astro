---
export interface Action {
  href: string;
  label: string;
  kind?: "accent" | "ghost";
}
const {
  kicker = "Parlons web",
  title = "Articles & notes",
  lead = "Des billets concis sur WordPress, l’accessibilité, la performance et des astuces concrètes.",
  actions = [] as Action[],
  tags = [
    "WordPress",
    "Design",
    "SEO",
    "Maintenance",
    "Securite",
    "Performance",
    "Plugins",
    "Themes",
    "Refonte",
    "Débuggage",
    "Audit",
  ],
} = Astro.props as {
  kicker?: string;
  title?: string;
  lead?: string;
  actions?: Action[];
  tags?: string[];
};

// normalisation simple pour matcher les couleurs par libellé
const tagKey = (s: string) =>
  s
    .normalize("NFD")
    .replace(/\p{Diacritic}/gu, "")
    .toLowerCase()
    .trim();
---

<section class="hbix hbix--localbg" aria-labelledby="hbix-title">
  <div class="hbix__inner container">
    <div class="hbix__text">
      {kicker && <p class="kicker">{kicker}</p>}
      {
        title && (
          <h1 id="hbix-title" class="title">
            {title}
          </h1>
        )
      }
      {lead && <p class="lead">{lead}</p>}
      {
        actions?.length ? (
          <div class="actions">
            {actions.map(({ href, label, kind = "accent" }) => (
              <a href={href} class={`btn btn--${kind}`}>
                {label}
              </a>
            ))}
          </div>
        ) : null
      }
    </div>

    <!-- Aire de jeu des tags -->
    <div class="hbix__stage" id="hbix-stage" aria-hidden="true">
      <ul class="hbix__chips" id="hbix-chips">
        {
          tags.slice(0, 12).map((t, i) => (
            <li class="chip" data-tag={tagKey(t)} style={`--i:${i}`}>
              <span>{t}</span>
            </li>
          ))
        }
      </ul>
    </div>
  </div>
</section>

<style>
  .container {
    width: min(1100px, 92vw);
    margin-inline: auto;
  }

  .hbix {
    position: relative;
    isolation: isolate; /* contexte propre pour les z-index */
    /* plus d’air en bas */
    padding: clamp(42px, 7vw, 84px) 0 clamp(56px, 6vw, 84px);
    margin-bottom: clamp(24px, 5vw, 72px);
  }

  .hbix__inner {
    position: relative;
    z-index: 2; /* texte au-dessus du halo local */
    display: grid;
    grid-template-columns: 1.05fr 0.95fr;
    gap: min(6vw, 48px);
    align-items: center;
  }
  @media (max-width: 900px) {
    .hbix__inner {
      grid-template-columns: 1fr;
    }
    .hbix__stage {
      order: -1;
      min-height: 240px;
    }
  }

  .hbix__text {
    max-width: 820px;
  }
  .kicker {
    margin: 0 0 0.45rem;
    font-weight: 600;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    font-size: 0.82rem;
    color: var(--muted, #cfd0e6);
  }
  .title {
    margin: 0 0 0.5rem;
    font-family: var(
      --font-head,
      "Josefin Sans",
      system-ui,
      -apple-system,
      Segoe UI,
      Roboto,
      Ubuntu,
      Cantarell,
      Noto Sans,
      "Helvetica Neue",
      Arial
    );
    font-size: clamp(1.8rem, 1.25rem + 2.2vw, 3rem);
    letter-spacing: -0.01em;
    line-height: 1.1;
  }
  .lead {
    margin: 0;
    color: var(--muted, #cfd0e6);
    max-width: 70ch;
    font-size: clamp(1rem, 0.96rem + 0.3vw, 1.15rem);
    line-height: 1.55;
  }

  .actions {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-top: clamp(12px, 1.2vw, 16px);
  }
  .btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    height: 42px;
    padding: 0 14px;
    border-radius: 12px;
    font-weight: 600;
    border: 2px solid transparent;
    text-decoration: none;
    transition:
      0.2s transform,
      0.2s background,
      0.2s color;
  }
  .btn:hover {
    transform: translateY(-1px);
  }
  .btn--accent {
    background: var(--accent, #ffd166);
    color: #111;
    border-color: var(--accent, #ffd166);
  }
  .btn--accent:hover {
    background: transparent;
    color: var(--fg, #f5f6fb);
  }
  .btn--ghost {
    background: transparent;
    color: var(--fg, #f5f6fb);
    border-color: var(--border, #31314a);
  }
  .btn--ghost:hover {
    border-color: var(--fg, #f5f6fb);
    background: rgba(245, 246, 251, 0.08);
  }

  /* ===== STAGE : transparent + halo local derrière les badges ===== */
  .hbix__stage {
    position: relative;
    isolation: isolate; /* confine le halo local */
    min-height: 320px;
    overflow: visible;
    background: transparent;
  }
  /* Halo “boost” (passe derrière les badges) */
  /* halo behind the chips: a bit calmer so it doesn't wash the badges */
  .hbix__stage::before {
    content: "";
    position: absolute;
    inset: -8% -6% -18% -6%;
    z-index: 0;
    pointer-events: none;
    background:
      radial-gradient(
        42% 40% at 25% 35%,
        rgba(106, 168, 255, 0.2),
        transparent 65%
      ),
      radial-gradient(
        38% 36% at 75% 30%,
        rgba(185, 132, 246, 0.18),
        transparent 70%
      ),
      radial-gradient(
        42% 40% at 55% 65%,
        rgba(255, 209, 102, 0.14),
        transparent 70%
      ),
      radial-gradient(
        36% 34% at 68% 58%,
        rgba(92, 199, 160, 0.18),
        transparent 70%
      ),
      radial-gradient(
        30% 28% at 48% 38%,
        rgba(213, 17, 17, 0.16),
        transparent 70%
      );
    filter: blur(22px) saturate(120%);
    opacity: 0.75;
    animation: none; /* pas de pulsation => plus net visuellement */
  }

  /* BADGE: remove blur, reduce glow, keep a thin outline for contrast */
  .chip {
    --c: rgba(59, 57, 80, 0.7);
    --cO: rgba(255, 255, 255, 0.22);
    --cG: rgba(0, 0, 0, 0); /* no colored glow by default */
    --ink: #fff;

    position: absolute;
    inset: auto;
    display: inline-grid;
    place-items: center;
    height: 38px;
    padding-inline: 14px;
    border-radius: 999px;
    font-weight: 700;
    font-size: 0.92rem;
    color: var(--ink);
    white-space: nowrap;

    /* keep just a gentle material effect, no blur */
    background:
      linear-gradient(
        180deg,
        rgba(255, 255, 255, 0.1),
        rgba(255, 255, 255, 0.02)
      ),
      var(--c);
    outline: 1px solid var(--cO);
    box-shadow: 0 8px 18px rgba(0, 0, 0, 0.18); /* toned down */
    text-shadow: none; /* crisper text */
    backdrop-filter: none; /* ← remove blur */
    -webkit-backdrop-filter: none;

    user-select: none;
    cursor: grab;
    pointer-events: auto;
    transition:
      filter 0.18s ease,
      box-shadow 0.18s ease,
      transform 0.18s ease;
    will-change: transform;
  }
  .chip:hover {
    filter: saturate(1.05) brightness(1.03);
    box-shadow: 0 10px 22px rgba(0, 0, 0, 0.22);
  }
  .chip:active {
    cursor: grabbing;
  }
  /* Palette = bulles du site (plus punchy) */
  /* Fallback par index si libellés changent */
  .chip:nth-child(1) {
    --c: rgba(106, 168, 255, 0.78);
    --cO: rgba(106, 168, 255, 0.62);
    --cG: rgba(106, 168, 255, 0.48);
  }
  .chip:nth-child(2) {
    --c: rgba(239, 147, 85, 0.78);
    --cO: rgba(239, 147, 85, 0.62);
    --cG: rgba(239, 147, 85, 0.48);
  }
  .chip:nth-child(3) {
    --c: rgba(92, 199, 160, 0.78);
    --cO: rgba(92, 199, 160, 0.62);
    --cG: rgba(92, 199, 160, 0.46);
  }
  .chip:nth-child(4) {
    --c: rgba(185, 132, 246, 0.8);
    --cO: rgba(185, 132, 246, 0.64);
    --cG: rgba(185, 132, 246, 0.5);
  }
  .chip:nth-child(5) {
    --c: rgba(213, 17, 17, 0.82);
    --cO: rgba(213, 17, 17, 0.64);
    --cG: rgba(213, 17, 17, 0.5);
  }
  .chip:nth-child(6) {
    --c: rgba(255, 209, 102, 0.86);
    --cO: rgba(255, 209, 102, 0.66);
    --cG: rgba(255, 209, 102, 0.52);
  }

  /* Couleurs par libellé (prioritaires sur le fallback) */
  .chip[data-tag="wordpress"] {
    --c: rgba(106, 168, 255, 0.78); /* bleu ciel */
    --cO: rgba(106, 168, 255, 0.62);
    --cG: rgba(106, 168, 255, 0.48);
  }

  .chip[data-tag="design"] {
    --c: rgba(239, 147, 85, 0.78); /* orange corail */
    --cO: rgba(239, 147, 85, 0.62);
    --cG: rgba(239, 147, 85, 0.48);
  }

  .chip[data-tag="seo"] {
    --c: rgba(92, 199, 160, 0.78); /* vert menthe */
    --cO: rgba(92, 199, 160, 0.62);
    --cG: rgba(92, 199, 160, 0.46);
  }

  .chip[data-tag="maintenance"] {
    --c: rgba(185, 132, 246, 0.8); /* violet doux */
    --cO: rgba(185, 132, 246, 0.64);
    --cG: rgba(185, 132, 246, 0.5);
  }

  .chip[data-tag="securite"],
  .chip[data-tag="sécurité"] {
    --c: rgba(213, 17, 17, 0.82); /* rouge alerte */
    --cO: rgba(213, 17, 17, 0.64);
    --cG: rgba(213, 17, 17, 0.5);
  }

  .chip[data-tag="performance"] {
    --c: rgba(255, 209, 102, 0.86); /* jaune punchy */
    --cO: rgba(255, 209, 102, 0.66);
    --cG: rgba(255, 209, 102, 0.52);
  }

  /* Nouvelles bulles */
  .chip[data-tag="plugins"] {
    /* magenta / rose soutenu */
    --c: rgba(236, 107, 173, 0.84);
    --cO: rgba(236, 107, 173, 0.66);
    --cG: rgba(236, 107, 173, 0.52);
  }

  .chip[data-tag="themes"] {
    /* cyan / turquoise clair */
    --c: rgba(96, 214, 230, 0.84);
    --cO: rgba(96, 214, 230, 0.66);
    --cG: rgba(96, 214, 230, 0.5);
  }

  .chip[data-tag="refonte"] {
    /* vert lime lumineux */
    --c: rgba(190, 230, 120, 0.86);
    --cO: rgba(190, 230, 120, 0.68);
    --cG: rgba(190, 230, 120, 0.54);
  }

  .chip[data-tag="debuggage"] {
    /* bleu indigo profond */
    --c: rgba(110, 125, 255, 0.84);
    --cO: rgba(110, 125, 255, 0.66);
    --cG: rgba(110, 125, 255, 0.52);
  }

  .chip[data-tag="audit"] {
    /* pêche / abricot doux */
    --c: rgba(255, 174, 131, 0.84);
    --cO: rgba(255, 174, 131, 0.66);
    --cG: rgba(255, 174, 131, 0.52);
  }

  /* RDM : anim off */
  @media (prefers-reduced-motion: reduce) {
    .hbix__stage::before {
      animation: none !important;
    }
    .hbix__chips {
      position: relative;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      padding: 14px;
    }
    .chip {
      position: relative;
      inset: auto;
      transform: none !important;
    }
  }
  /* Étend un halo fixé à l’écran, visible UNIQUEMENT sur cette page */
  .hbix--page-halo {
    position: relative;
    isolation: isolate; /* pour que z-index:-1 reste derrière le contenu */
  }

  /* Le halo “long” de la page blog */
  .hbix--page-halo::before {
    content: "";
    position: fixed;
    inset: 0;
    z-index: -1; /* derrière tout le contenu de la page */
    pointer-events: none;

    /* dimensions + placement -> halo plus long et plus large */
    left: 50%;
    top: -18vh; /* remonte légèrement */
    width: max(1600px, 90vw);
    height: 110vh; /* ← allongé */
    transform: translateX(-50%) rotate(-6deg);
    opacity: 0.92;

    /* teintes (palette proche de l’accueil) */
    background:
      radial-gradient(
        60% 55% at 28% 36%,
        rgba(106, 168, 255, 0.24),
        transparent 66%
      ),
      radial-gradient(
        52% 48% at 72% 30%,
        rgba(185, 132, 246, 0.22),
        transparent 70%
      ),
      radial-gradient(
        58% 52% at 56% 64%,
        rgba(255, 209, 102, 0.18),
        transparent 72%
      ),
      radial-gradient(
        48% 44% at 66% 58%,
        rgba(92, 199, 160, 0.2),
        transparent 72%
      ),
      radial-gradient(
        34% 32% at 46% 40%,
        rgba(213, 17, 17, 0.18),
        transparent 74%
      );

    /* un peu plus de matière et de douceur */
    filter: blur(52px) saturate(122%);

    /* masque plus grand pour laisser descendre le halo */
    -webkit-mask-image: radial-gradient(
      150% 135% at 50% 54%,
      #000 58%,
      transparent 100%
    );
    mask-image: radial-gradient(
      150% 135% at 50% 54%,
      #000 58%,
      transparent 100%
    );
  }

  /* Optionnel : un léger tapis sombre très diffus en bas pour la profondeur */
  .hbix--page-halo::after {
    content: "";
    position: fixed;
    inset: 0;
    z-index: -1;
    pointer-events: none;
    background: radial-gradient(
      80% 40% at 50% 112%,
      color-mix(in srgb, var(--card, #232333) 14%, transparent) 0%,
      transparent 70%
    );
    filter: blur(34px) saturate(106%);
    opacity: 0.5;
  }

  /* Adaptations mobile pour éviter un halo trop présent sur petits écrans */
  @media (max-width: 900px) {
    .hbix--page-halo::before {
      top: -14vh;
      width: max(1200px, 100vw);
      height: 95vh;
      opacity: 0.88;
      filter: blur(46px) saturate(118%);
      transform: translateX(-50%) rotate(-4deg);
    }
  }
</style>

<script type="module">
  // Moteur physique DOM — lent & doux + collisions entre badges
  const stage = document.getElementById("hbix-stage");
  const list = document.getElementById("hbix-chips");
  const CAN_ANIM = matchMedia(
    "(prefers-reduced-motion: no-preference)"
  ).matches;

  if (stage && list && CAN_ANIM) {
    const chips = Array.from(list.children);

    // Réglages
    const R = 110; // rayon d’influence du pointeur
    const FORCE = 900; // répulsion pointeur
    const DAMP = 0.94; // amortissement linéaire
    const DAMP_ROT = 0.94; // amortissement angulaire
    const SPRING = 0.02; // rappel bords
    const WANDER = 4; // errance (px/s)
    const WSPIN = 8; // rotation autonome (deg/s)
    const BOUNCE = 0.5; // restitution à l’impact (0..1)

    const state = new Map(); // chip -> {x,y,vx,vy,w,h,a,av,t,r}
    const bounds = { w: 0, h: 0 };
    let mx = -9999,
      my = -9999,
      dragging = null,
      raf = 0,
      lastTs = performance.now();

    new ResizeObserver(updateBounds).observe(stage);
    updateBounds();

    // positions initiales
    chips.forEach((el, i) => {
      const w = el.offsetWidth || 120;
      const h = el.offsetHeight || 38;
      const cols = 3;
      const cx = (i % cols) + 0.5;
      const cy = Math.floor(i / cols) + 0.6;
      const x = (cx / cols) * (bounds.w - w) + 8;
      const y = (cy / Math.ceil(chips.length / cols)) * (bounds.h - h) + 8;

      // rayon d’approximation (les badges sont “pills” -> on prend ~hauteur/2 + marge)
      const r = Math.max(h * 0.55, 18);

      const t = Math.random() * Math.PI * 2;
      state.set(el, {
        x,
        y,
        vx: 0,
        vy: 0,
        w,
        h,
        r,
        a: 0,
        av: 0,
        t,
        dragAng: null,
      });
      el.style.transform = `translate(${x}px, ${y}px) rotate(0deg)`;
    });

    // pointeur
    stage.addEventListener("pointermove", (e) => {
      const r = stage.getBoundingClientRect();
      mx = e.clientX - r.left;
      my = e.clientY - r.top;

      if (dragging) {
        const s = state.get(dragging);
        const cx = s.x + s.w / 2,
          cy = s.y + s.h / 2;
        const ang = Math.atan2(my - cy, mx - cx);
        if (s.dragAng !== null) {
          const d = normalizeAngle(ang - s.dragAng);
          const deg = d * (180 / Math.PI);
          s.a += deg * 4;
          s.av += deg * 12;
        }
        s.dragAng = ang;
      }
    });
    stage.addEventListener("pointerleave", () => {
      mx = my = -9999;
    });

    // drag
    chips.forEach((el) => {
      el.addEventListener("pointerdown", (e) => {
        dragging = el;
        const s = state.get(el);
        s.dragAng = null;
        el.setPointerCapture(e.pointerId);
      });
      el.addEventListener("pointerup", () => {
        const s = state.get(el);
        if (s) s.dragAng = null;
        dragging = null;
      });
    });

    function updateBounds() {
      const r = stage.getBoundingClientRect();
      bounds.w = r.width;
      bounds.h = r.height;
    }

    function step(ts) {
      const dt = Math.min(0.032, (ts - lastTs) / 1000);
      lastTs = ts;

      // 1) forces & intégration de base
      chips.forEach((el) => {
        const s = state.get(el);
        if (!s) return;

        // errance/rotation douces
        s.t += dt;
        s.vx += Math.cos(s.t * (0.9 + (s.w % 7) / 10)) * WANDER * dt;
        s.vy += Math.sin(s.t * (1.1 + (s.h % 5) / 10)) * WANDER * dt;
        s.av += Math.sin(s.t * 1.3) * (WSPIN * dt);

        // répulsion pointeur
        const cx = s.x + s.w / 2,
          cy = s.y + s.h / 2;
        const dx = cx - mx,
          dy = cy - my;
        const dist2 = dx * dx + dy * dy;
        if (dist2 < R * R) {
          const dist = Math.max(12, Math.sqrt(dist2));
          const f = FORCE / (dist * dist);
          s.vx += (dx / dist) * f * dt;
          s.vy += (dy / dist) * f * dt;
        }

        // suivi lors du drag
        if (dragging === el) {
          s.vx += (mx - cx) * 4 * dt;
          s.vy += (my - cy) * 4 * dt;
        }

        // rappel bords (spring)
        const pad = 8;
        const maxX = bounds.w - s.w - pad,
          maxY = bounds.h - s.h - pad;
        if (s.x < pad) s.vx += (pad - s.x) * SPRING;
        if (s.y < pad) s.vy += (pad - s.y) * SPRING;
        if (s.x > maxX) s.vx += (maxX - s.x) * SPRING;
        if (s.y > maxY) s.vy += (maxY - s.y) * SPRING;

        // intégration
        s.vx *= Math.pow(DAMP, 60 * dt);
        s.vy *= Math.pow(DAMP, 60 * dt);
        s.x += s.vx;
        s.y += s.vy;

        s.av *= Math.pow(DAMP_ROT, 60 * dt);
        s.a += s.av * dt;
      });

      // 2) collisions pair-à-pair (approx cercles)
      for (let i = 0; i < chips.length; i++) {
        const ei = chips[i],
          si = state.get(ei);
        const cxi = si.x + si.w / 2,
          cyi = si.y + si.h / 2;

        for (let j = i + 1; j < chips.length; j++) {
          const ej = chips[j],
            sj = state.get(ej);
          const cxj = sj.x + sj.w / 2,
            cyj = sj.y + sj.h / 2;

          let dx = cxj - cxi;
          let dy = cyj - cyi;
          let dist = Math.hypot(dx, dy) || 0.0001;
          const minDist = si.r + sj.r;

          if (dist < minDist) {
            // vecteur normal
            const nx = dx / dist,
              ny = dy / dist;
            const overlap = minDist - dist;

            // séparation 50/50 (sauf si on en “tient” un)
            const m1 = dragging === ei ? 0.1 : 0.5;
            const m2 = dragging === ej ? 0.1 : 0.5;

            si.x -= nx * overlap * m1;
            si.y -= ny * overlap * m1;
            sj.x += nx * overlap * m2;
            sj.y += ny * overlap * m2;

            // composante normale des vitesses (petit rebond)
            const rvx = sj.vx - si.vx;
            const rvy = sj.vy - si.vy;
            const relVelNorm = rvx * nx + rvy * ny;

            const impulse = -(1 + BOUNCE) * relVelNorm * 0.5;
            si.vx -= impulse * nx;
            si.vy -= impulse * ny;
            sj.vx += impulse * nx;
            sj.vy += impulse * ny;
          }
        }
      }

      // 3) clamp final (évite de passer les bords après collision)
      const pad = 8;
      chips.forEach((el) => {
        const s = state.get(el);
        const maxX = bounds.w - s.w - pad,
          maxY = bounds.h - s.h - pad;
        s.x = Math.max(pad, Math.min(maxX, s.x));
        s.y = Math.max(pad, Math.min(maxY, s.y));
        el.style.transform = `translate(${s.x}px, ${s.y}px) rotate(${s.a}deg)`;
      });

      raf = requestAnimationFrame(step);
    }

    raf = requestAnimationFrame(step);
    document.addEventListener(
      "visibilitychange",
      () => {
        if (document.hidden) cancelAnimationFrame(raf);
        else {
          lastTs = performance.now();
          raf = requestAnimationFrame(step);
        }
      },
      { passive: true }
    );
  }

  function normalizeAngle(a) {
    while (a > Math.PI) a -= Math.PI * 2;
    while (a < -Math.PI) a += Math.PI * 2;
    return a;
  }
</script>
